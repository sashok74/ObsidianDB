# Селекторы MERP (старая реализация)

## 1. Схема заполнения селектора данными

```mermaid
graph TD
    A[Начало - FillItemCombo] --> B[Получение соединения<br/>m_pDBConnection]
    B --> C[Формирование SQL-запроса<br/>в теле метода]
    C --> D[Создание ADO Recordset]
    D --> E[Выполнение запроса]
    E --> F[Цикл по записям<br/>while !pRS->adoEOF]
    F --> G[Создание объекта сущности<br/>new CEntity]
    G --> H[Заполнение полей из recordset]
    H --> I[Добавление в m_Items]
    I --> J[Добавление в комбобокс<br/>AddString + SetItemData]
    J --> K{Есть еще<br/>записи?}
    K -->|Да| F
    K -->|Нет| L[Установка выбранного<br/>значения если есть<br/>iIDToSelect]
    L --> M[Конец]
```

## 2. Описание работы схемы заполнения

### Основные методы и их роль:

#### FillItemCombo
```cpp
void CSomeSelectorCombo::FillItemCombo(LPCTSTR pStr = nullptr, int iIDToSelect = -1)
{
    // Очистка предыдущих данных
    ClearItems();
    m_pCombo->ResetContent();

    // Формирование SQL-запроса
    CString sSQL;
    sSQL.Format(_T("SELECT ID, Name, Code FROM SomeTable WHERE Deleted = 0"));
    if (pStr && _tcslen(pStr))
        sSQL.AppendFormat(_T(" AND Name LIKE '%%%s%%'"), pStr);

    // Выполнение запроса через ADO
    _RecordsetPtr pRS;
    pRS.CreateInstance(__uuidof(Recordset));
    pRS->Open(sSQL.AllocSysString(), 
              m_pDBConnection->GetActiveConnection().GetInterfacePtr(),
              adOpenStatic, adLockOptimistic, adCmdText);
}
```

#### Создание и заполнение объектов
```cpp
while (!pRS->adoEOF)
{
    // Создание объекта
    CSomeEntity* pEntity = new CSomeEntity();
    
    // Заполнение полей
    pEntity->m_iID = (int)pRS->Fields->GetItem("ID")->Value;
    pEntity->m_sName = (LPCTSTR)(_bstr_t)pRS->Fields->GetItem("Name")->Value;
    
    // Добавление в список
    m_Items.push_back(pEntity);
    
    // Добавление в комбобокс
    int iIndex = m_pCombo->AddString(pEntity->GetDisplayName());
    m_pCombo->SetItemData(iIndex, (DWORD_PTR)pEntity->m_iID);
    
    pRS->MoveNext();
}
```

## 3. Схема использования селектора в приложении

```mermaid
graph TD
    A[Создание диалога] --> B[Создание селектора<br/>CSomeSelectorCombo]
    B --> C[Инициализация селектора<br/>Init]
    C --> D[Настройка параметров<br/>SetParams]
    D --> E{Тип инициализации}
    E -->|SSetup| F1[Прямая инициализация<br/>через указатели]
    E -->|SSetupID| F2[Инициализация через<br/>ID контролов]
    F1 --> G[Первичное заполнение<br/>FillItemCombo]
    F2 --> G
    G --> H[Ожидание действий<br/>пользователя]
    H --> I{Событие}
    I -->|Ввод текста| J[OnEditChange<br/>Фильтрация]
    I -->|Выбор| K[OnSelChange<br/>Обработка выбора]
    I -->|Создать| L[OnCreateBtnClicked]
    I -->|Изменить| M[OnModifyBtnClicked]
    J --> N[FillItemCombo с<br/>параметром фильтра]
    K --> O[Получение выбранного<br/>GetSelectedID]
    L --> P[Вызов диалога<br/>создания]
    M --> Q[Вызов диалога<br/>редактирования]
```

## 4. Описание схемы использования

### Инициализация селектора
```cpp
// В конструкторе диалога
m_SomeSelector.Init(SSetupID(
    this,                   // владелец
    IDC_BTN_CREATE,        // ID кнопки создания
    IDC_BTN_MODIFY,        // ID кнопки изменения
    IDC_BTN_DELETE,        // ID кнопки удаления
    IDC_COMBO_SELECTOR,    // ID комбобокса
    pDBConnection          // соединение с БД
));
```

### Обработка событий
```cpp
// Обработка изменения текста
void CSomeSelectorCombo::OnEditChange()
{
    CString sText;
    m_pCombo->GetWindowText(sText);
    FillItemCombo(sText);
}

// Обработка выбора
void CSomeSelectorCombo::OnSelChange()
{
    int iCurSel = m_pCombo->GetCurSel();
    if (iCurSel != CB_ERR)
    {
        int iSelectedID = (int)m_pCombo->GetItemData(iCurSel);
        // Дополнительная обработка выбора
    }
}

// Создание нового элемента
void CSomeSelectorCombo::OnCreateBtnClicked()
{
    CSomeDialog dlg;
    if (dlg.DoModal() == IDOK)
    {
        // Обновление списка
        FillItemCombo();
    }
}
```

### Получение выбранного значения
```cpp
int CSomeSelectorCombo::GetSelectedID()
{
    int iCurSel = m_pCombo->GetCurSel();
    if (iCurSel != CB_ERR)
        return (int)m_pCombo->GetItemData(iCurSel);
    return m_iInvalidID;
}
```

### Основные проблемы старого подхода:

1. **Прямой SQL в коде**
   - SQL-запросы написаны непосредственно в методах
   - Сложность поддержки и изменения запросов
   - Отсутствие переиспользования запросов

2. **Жесткая привязка к ADO**
   - Прямое использование ADO Recordset
   - Сложность замены технологии доступа к данным

3. **Дублирование кода**
   - Каждый селектор содержит похожий код
   - Высокая вероятность ошибок при копировании

4. **Отсутствие абстракции**
   - Нет разделения на слои доступа к данным
   - Смешивание UI-логики и работы с данными

5. **Ручное управление памятью**
   - Необходимость явного удаления объектов
   - Возможность утечек памяти