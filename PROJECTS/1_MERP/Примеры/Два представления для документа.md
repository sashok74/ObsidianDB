# Создание двух представлений для одного документа

## 1. Определение классов представлений

```cpp
// MyDoc.h
class CMyDoc : public CDocument {
    DECLARE_DYNCREATE(CMyDoc)
protected:
    // Данные документа
    int m_iSomeData;
public:
    // Методы для доступа к данным
    int GetData() const { return m_iSomeData; }
    void SetData(int val) { m_iSomeData = val; SetModifiedFlag(); }
};

// FirstView.h
class CFirstView : public CView {
    DECLARE_DYNCREATE(CFirstView)
protected:
    CMFCRibbonCategory* m_pCategory;
    CMFCRibbonPanel* m_pPanel;
    
public:
    virtual void OnInitialUpdate() override;
    void OnSetContextRibbon(CMFCRibbonCategory* pCategory);
    
protected:
    afx_msg void OnFirstViewButton1();
    afx_msg void OnFirstViewButton2();
    afx_msg void OnUpdateFirstViewButton1(CCmdUI* pCmdUI);
    DECLARE_MESSAGE_MAP()
};

// SecondView.h
class CSecondView : public CView {
    DECLARE_DYNCREATE(CSecondView)
protected:
    CMFCRibbonCategory* m_pCategory;
    CMFCRibbonPanel* m_pPanel;
    
public:
    virtual void OnInitialUpdate() override;
    void OnSetContextRibbon(CMFCRibbonCategory* pCategory);
    
protected:
    afx_msg void OnSecondViewButton1();
    afx_msg void OnSecondViewButton2();
    afx_msg void OnUpdateSecondViewButton1(CCmdUI* pCmdUI);
    DECLARE_MESSAGE_MAP()
};
```

## 2. Реализация представлений

```cpp
// FirstView.cpp
IMPLEMENT_DYNCREATE(CFirstView, CView)

BEGIN_MESSAGE_MAP(CFirstView, CView)
    ON_COMMAND(ID_FIRST_VIEW_BTN1, OnFirstViewButton1)
    ON_COMMAND(ID_FIRST_VIEW_BTN2, OnFirstViewButton2)
    ON_UPDATE_COMMAND_UI(ID_FIRST_VIEW_BTN1, OnUpdateFirstViewButton1)
END_MESSAGE_MAP()

void CFirstView::OnInitialUpdate() {
    CView::OnInitialUpdate();
    // Инициализация представления
}

void CFirstView::OnSetContextRibbon(CMFCRibbonCategory* pCategory) {
    m_pCategory = pCategory;
    
    // Создаем панель для первого представления
    m_pPanel = m_pCategory->AddPanel(L"Первое представление");
    
    // Добавляем кнопки
    CMFCRibbonButton* pButton1 = new CMFCRibbonButton(
        ID_FIRST_VIEW_BTN1, 
        L"Кнопка 1", 
        -1, 
        +eRbnButtonPicID::Create
    );
    m_pPanel->Add(pButton1);
    
    CMFCRibbonButton* pButton2 = new CMFCRibbonButton(
        ID_FIRST_VIEW_BTN2, 
        L"Кнопка 2", 
        -1, 
        +eRbnButtonPicID::Modify
    );
    m_pPanel->Add(pButton2);
}

void CFirstView::OnFirstViewButton1() {
    CMyDoc* pDoc = GetDocument();
    // Обработка нажатия кнопки 1
}

void CFirstView::OnFirstViewButton2() {
    CMyDoc* pDoc = GetDocument();
    // Обработка нажатия кнопки 2
}

void CFirstView::OnUpdateFirstViewButton1(CCmdUI* pCmdUI) {
    pCmdUI->Enable(TRUE); // Логика активации/деактивации
}

// SecondView.cpp
IMPLEMENT_DYNCREATE(CSecondView, CView)

BEGIN_MESSAGE_MAP(CSecondView, CView)
    ON_COMMAND(ID_SECOND_VIEW_BTN1, OnSecondViewButton1)
    ON_COMMAND(ID_SECOND_VIEW_BTN2, OnSecondViewButton2)
    ON_UPDATE_COMMAND_UI(ID_SECOND_VIEW_BTN1, OnUpdateSecondViewButton1)
END_MESSAGE_MAP()

void CSecondView::OnSetContextRibbon(CMFCRibbonCategory* pCategory) {
    m_pCategory = pCategory;
    
    // Создаем панель для второго представления
    m_pPanel = m_pCategory->AddPanel(L"Второе представление");
    
    // Добавляем кнопки
    CMFCRibbonButton* pButton1 = new CMFCRibbonButton(
        ID_SECOND_VIEW_BTN1, 
        L"Кнопка 1", 
        -1, 
        +eRbnButtonPicID::Create
    );
    m_pPanel->Add(pButton1);
    
    CMFCRibbonButton* pButton2 = new CMFCRibbonButton(
        ID_SECOND_VIEW_BTN2, 
        L"Кнопка 2", 
        -1, 
        +eRbnButtonPicID::Modify
    );
    m_pPanel->Add(pButton2);
}
```

## 3. Настройка фреймов

```cpp
// ChildFrm.h
class CChildFrame : public CMDIChildWndEx {
    DECLARE_DYNCREATE(CChildFrame)
protected:
    CSplitterWndEx m_wndSplitter;
public:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) override;
};

// ChildFrm.cpp
BOOL CChildFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) {
    if (!m_wndSplitter.CreateStatic(this, 1, 2))  // 1 строка, 2 колонки
        return FALSE;

    // Создаем первое представление
    if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CFirstView), 
        CSize(300, 100), pContext))
        return FALSE;

    // Создаем второе представление
    if (!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CSecondView), 
        CSize(300, 100), pContext))
        return FALSE;

    return TRUE;
}
```

## 4. Управление лентой при переключении представлений

```cpp
// MainFrm.cpp
void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle) {
    CMDIFrameWndEx::OnUpdateFrameTitle(bAddToTitle);
    
    // Получаем активное представление
    CMDIChildWndEx* pChild = MDIGetActive();
    if (!pChild) return;
    
    CView* pView = pChild->GetActiveView();
    if (!pView) return;
    
    // Обновляем ленту в зависимости от типа представления
    CMRibbonBar& ribbon = GetRibbonBar();
    CMFCRibbonCategory* pCategory = ribbon.GetActionCategory();
    
    if (pCategory) {
        if (pView->IsKindOf(RUNTIME_CLASS(CFirstView))) {
            ((CFirstView*)pView)->OnSetContextRibbon(pCategory);
        }
        else if (pView->IsKindOf(RUNTIME_CLASS(CSecondView))) {
            ((CSecondView*)pView)->OnSetContextRibbon(pCategory);
        }
        ribbon.ForceRecalcLayout();
    }
}
```

## 5. Идентификаторы команд

В файле resource.h:
```cpp
#define ID_FIRST_VIEW_BTN1    WM_USER + 100
#define ID_FIRST_VIEW_BTN2    WM_USER + 101
#define ID_SECOND_VIEW_BTN1   WM_USER + 102
#define ID_SECOND_VIEW_BTN2   WM_USER + 103
```

## Ключевые моменты

1. **Разделение представлений**:
   - Каждое представление имеет свой собственный класс
   - Каждое представление имеет свои уникальные идентификаторы команд
   - Каждое представление создает свою панель в ленте

2. **Управление лентой**:
   - При переключении между представлениями обновляется лента
   - Каждое представление отвечает за создание своих элементов ленты
   - Используются уникальные идентификаторы для команд

3. **Доступ к данным**:
   - Оба представления имеют доступ к одному документу
   - Изменения в документе отражаются в обоих представлениях

4. **Обработка событий**:
   - Каждое представление имеет свою карту сообщений
   - События обрабатываются независимо в каждом представлении

## Пример использования

```cpp
// В обработчике первого представления
void CFirstView::OnFirstViewButton1() {
    CMyDoc* pDoc = GetDocument();
    pDoc->SetData(42);
    Invalidate(); // Обновляем первое представление
    
    // Находим и обновляем второе представление
    CView* pOtherView = GetNextWindow();
    if (pOtherView && pOtherView->IsKindOf(RUNTIME_CLASS(CSecondView))) {
        pOtherView->Invalidate();
    }
}

// В обработчике второго представления
void CSecondView::OnSecondViewButton1() {
    CMyDoc* pDoc = GetDocument();
    pDoc->SetData(100);
    Invalidate(); // Обновляем второе представление
    
    // Находим и обновляем первое представление
    CView* pOtherView = GetNextWindow();
    if (pOtherView && pOtherView->IsKindOf(RUNTIME_CLASS(CFirstView))) {
        pOtherView->Invalidate();
    }
}
```

## Советы по отладке

1. Убедитесь, что идентификаторы команд уникальны для каждого представления
2. Проверьте, что сплиттер правильно создает оба представления
3. При переключении между представлениями проверяйте, что лента корректно обновляется
4. Используйте TRACE для отладки событий и обновлений представлений