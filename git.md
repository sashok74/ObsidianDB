##Эквивалент git clone,  без повторной загрузки  
```bash
git reset && git checkout . && git clean -fdx
```
чего-либо
```bash
git remote get-url --all origin
git status
git status --ignored
git config
git log
git log --graph --oneline --all
git remote add origin https://github.com/user/repo.git
git remote git remote add <address>
git clone <https://name-of-the-repository-link>
git branch <branch-name>			#Creating a new branch
git branch or git branch --list		#Viewing branches
git branch -d <branch-name>			#Deleting a branchgi
git checkout <name-of-your-branch>  #Git checkout
```
git diff
git revert 3321844
git check-ignore -vn *
git add <file> (gitgit reset)
git add -A
git commit -m "commit message"
git merge <branch-name>	
git push <remote> <branch-name>
git pull <remote>


git checkout dev					Вливаем свою
git fetch							ветку в dev	
git merge <branch-name>		


Git global setup

git config --global user.name "Макаренко Александр"
git config --global user.email "makarenko@planarchel.ru"

### Create a new repository
git clone git@gitlab.skillbox.ru:skillbox3/react.git
cd react
git switch -c main
touch README.mdпше 
git add README.md
git commit -m "add README"
git commit -a -m "комментарий $(date +%Y-%m-%d-%H_%M)" все добавить и закомитить с датой.
git push -u origin main

для гитлаба - пуш новой ветки и пуш-реквест в мастер.
git push -u origin dev -o merge_request.create -o merge_request.target=master -o merge_request.title="Домашнее задание"

### Push an existing folder
cd existing_folder
git init --initial-branch=main
git remote add origin git@gitlab.skillbox.ru:skillbox3/react.git
git add .
git commit -m "Initial commit"
git push -u origin main

### Push an existing Git repository
cd existing_repo
git remote rename origin old-origin
git remote add origin git@gitlab.skillbox.ru:skillbox3/react.git
git push -u origin --all
git push -u origin --tags

### Отмены

git reset --soft HEAD~1      без отмены изменений
git reset --hard HEAD~1		с отменой изменений
git revert commit-sha		на сервере
пример 
git.exe reset -q HEAD -- ISPlanar\ISPlanar.res


### Алиасы

git config --global alias.tree "log --oneline --decorate --all --graph"
git tree

### Переключиться на ветку на сервере
```bash
git branch --all 
git checkout remotes/origin/develop
git branch --all
git checkout -b develop
```
### привязать удаленную ветку к существующей локальной.

git branch --set-upstream-to=origin/dev dev

### История изменений фалов  git log

(флаги, приведенные ниже можно комбинировать)

git log	Журнал всех изменений:
git log  --name-only С перечислением имен измененных файлов в каждом коммите:
git log --oneline --name-only Или тоже самое с короткими хэшами и более кратко/аккуратно:
git log  -p С подробной информацией об изменениях в каждом коммите:
git log -p путьКфайлу История изменений конкретного файла:
git log  --author="ИмяПользователя" Фильтрация истории изменений по имени пользователя:
git log --oneline Вывод истории с короткими хэшами коммитов (краткая форма):

Если хотите сравнить все изменения от начала ветки до текущего состояния:

```bash
git diff --name-only $(git merge-base <branch> master) <branch>
```
Какие коммиты меняли файл.
```bash
git log --pretty=format:"%h %ad %s" --date=short -- example.txt
```
### DIFF

--stat
--name-only			только имена файлов

git diff 			work dir --> index
git diff --cached                index --> HEAD
git diff HEAD       work dir ------------> HEAD 

исключить *package*.json
git diff 656d3d6 10df5d3 --stat ':(exclude)*package*.json'

директории
git diff --no-index ./dir1/ ./dir2/ --name-only
=======
### правим историю интерактивно

git rebase -i HEAD~4  правим в редакторе коммиты.
затем
git push origin dev --force

### rebase
есть ветка с модификацией, которую я хочу всегда добавлять к последней основной.
git ch techno
git rebase ISplanar

### конфликт

исправляем файлы.
git add <file>..." to mark resolution
git rebase --continue "если конфликт на ребейзе"

### Конфликты в Git

"Конфликты в Git могут возникнуть в различных ситуациях, когда несколько изменений в одних и тех же строках файла или структуре проекта пытаются совместиться, но Git не может определить, какое изменение предпочтительнее. Вот несколько распространенных сценариев, которые приводят к конфликтам:

1. **Слияние веток (Merge):** Когда вы пытаетесь объединить две ветки, которые имеют различные изменения в одинаковых частях кода, Git не может автоматически разрешить различия между ними.

2. **Интерактивное слияние (Interactive rebase):** При переупорядочивании, изменении или сжатии коммитов, вы можете столкнуться с конфликтами, если последующие изменения зависят от предыдущих.

3. **Применение патчей (Cherry-picking):** Если вы пытаетесь применить изменения из одной ветки в другую с помощью cherry-pick и эти изменения пересекаются с локальными изменениями, это может привести к конфликтам.

4. **Стягивание изменений (Pull):** Когда вы делаете `git pull` (который является комбинацией `git fetch` + `git merge`), можно столкнуться с конфликтами, если локальные изменения в текущей ветке пересекаются с изменениями, стянутыми из удаленного репозитория.

5. **Обновление ссылок в удалённом репозитории (Push):** Если кто-то уже обновил ветку в удаленном репозитории с момента последнего `fetch` или `pull`, и вы пытаетесь запушить свои изменения без предварительного слияния, то удаленный репозиторий отклонит ваш `push`, так как это может вызвать конфликт на удаленной стороне.

Чтобы решить конфликты в Git, вы обычно должны вручную редактировать файлы с конфликтами, выбирать правильные изменения, а затем завершить процесс слияния или ребейза. В файлах с конфликтами Git добавляет специальные маркеры, которые помогают определить области изменений (конфликты), чтобы упростить их поиск и исправление."

>>
Как посмотреть список файлов с кофликтами?

Чтобы посмотреть список файлов с конфликтами в Git, вы можете использовать команду `git status`. Вот как это сделать:

```bash
git status
```

После выполнения этой команды Git покажет текущее состояние вашего рабочего каталога, включая файлы с конфликтами. Файлы с конфликтами будут отображены в секции "Unmerged paths" (неслившиеся пути) в выводе команды `git status`.

Чтобы более детально просмотреть файлы с конфликтами или увидеть их изменения, вы можете использовать команду `git diff`. Например:

```bash
git diff
```

Эта команда покажет вам различия между вашими изменениями и изменениями из других веток, включая области, где возникли конфликты."

>> 
как можно посмотреть версию файла до конфликта?

"Чтобы посмотреть версию файла до конфликта в Git, вы можете использовать команды для просмотра содержимого файлов из различных сторон конфликта: "ancestor" (общий предок), "ours" (текущая ветка) и "theirs" (ветка, в которую производится слияние или откуда осуществляется ребейз).

Используйте следующие команды, чтобы извлечь и просмотреть файлы в этих различных состояниях:

1. Ancestor (общий предок, базовая версия до обеих изменённых):
   ```bash
   git show :1:путь/к/файлу > файл_ancestor.txt
   ```

2. Ours (текущая ветка, версия файла из вашей ветки до конфликта):
   ```bash
   git show :2:путь/к/файлу > файл_ours.txt
   ```

3. Theirs (другая ветка, версия файла из ветки, с которой происходит слияние):
   ```bash
   git show :3:путь/к/файлу > файл_theirs.txt
   ```
Эти команды выполняют `show` на конкретных "стадиях" (`stage`) файла в индексе, где `:1:`, `:2:`, и `:3:` указывают на версию файла из общего предка, текущей ветки, и ветки слияния соответственно.

>>
как разрешить конфликт?
по шагам с примером команды


Чтобы разрешить конфликт в Git, вам нужно следовать нескольким шагам. Ниже приведён пример общего процесса разрешения конфликта в Git с командами:

1. Выявление конфликтующих файлов:
   ```bash
   git status
   ```
   Эта команда покажет список файлов, содержащих конфликты.

2. Редактирование файлов для разрешения конфликтов:
   
   Откройте каждый файл с конфликтом в вашем любимом текстовом редакторе. Git помечает конфликты в файле специальными маркерами:
   ```
   <<<<<<< HEAD
   Ваш код или изменения в текущей ветке
   =======
   Код или изменения из ветки, с которой происходит слияние
   >>>>>>> название_ветки
   ```
   Определите, какие изменения необходимо сохратить, измените файлы и удалите маркеры конфликта. Конфликты могут быть разрешены путём выбора одной из сторон, совмещения обоих изменений или создания нового кода, который объединяет обе стороны.

3. Добавление файлов после ручного разрешения конфликтов:
   ```bash
   git add путь/к/файлу
   ```
   После редактирования файлов и исправления всех конфликтов нужно проиндексировать их с помощью команды `git add`. Здесь `путь/к/файлу` — это путь к файлу, в котором был разрешён конфликт.

4. Завершение процесса слияния после разрешения всех конфликтов:
   Если вы разрешали конфликты в процессе слияния:
   ```bash
   git commit
   ```
   Git откроет редактор сообщений коммитов с предзаполненным сообщением о слиянии. Вы можете опционально добавить свои комментарии к этому сообщению. После сохранения и закрытия редактора слияние будет завершено.

   Если вы разрешали конфликты в процессе ребейза:
   ```bash
   git rebase --continue
   ```
   Эта команда перенесёт вас к следующему шагу в ребейзе. Если будут другие конфликты, процесс нужно будет повторить. Если нет, ребейз продолжится и в конце завершится.

5. Проверка и тестирование:
   После разрешения конфликтов и завершения слияния или ребейза, проверьте код еще раз и выполните тестирование, чтобы убедиться, что изменения не нарушили функциональность проекта.

Это базовые шаги разрешения конфликтов. В зависимости от размера проекта и сложности конфликтов, процесс может потребовать дополнительных шагов, таких как общение с другими разработчиками, чтобы обсудить и определить правильное разрешение конфликта, или использование инструментов сравнения версий (diff tools) для управления конфликтами.

