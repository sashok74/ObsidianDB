
# Руководство по работе с потоками в C++

  

## Содержание

1. [Создание и управление потоками](#1-создание-и-управление-потоками)

2. [Синхронизация с мьютексами](#2-синхронизация-с-мьютексами)

3. [Условные переменные](#3-условные-переменные)

4. [Очереди для межпоточного обмена](#4-очереди-для-межпоточного-обмена)

5. [Типичный паттерн работы с потоками](#5-типичный-паттерн-работы-с-потоками)

6. [Важные правила](#6-важные-правила)

7. [Типичные ошибки](#7-типичные-ошибки)

  

## 1. Создание и управление потоками

  

```cpp

// Создание потока

std::thread thread_name([&]() {

    // код потока

});

  

// Ожидание завершения потока

thread_name.join();

  

// Отсоединение потока (не рекомендуется)

// thread_name.detach();

```

  

**Порядок действий:**

1. Создать поток

2. Выполнить необходимые действия в потоке

3. Дождаться завершения потока через `join()`

  

## 2. Синхронизация с мьютексами

  

```cpp

// Объявление мьютекса

std::mutex mutex_name;

  

// Использование с lock_guard (рекомендуется)

{

    std::lock_guard<std::mutex> lock(mutex_name);

    // защищенный код

} // мьютекс автоматически освобождается

  

// Использование с unique_lock (для условных переменных)

std::unique_lock<std::mutex> lock(mutex_name);

// защищенный код

lock.unlock(); // явное освобождение

```

  

**Порядок действий:**

1. Объявить мьютекс

2. Захватить мьютекс через `lock_guard` или `unique_lock`

3. Выполнить защищенный код

4. Мьютекс автоматически освобождается при выходе из блока

  

## 3. Условные переменные

  

```cpp

// Объявление условной переменной

std::condition_variable cv;

  

// Ожидание в потоке

std::unique_lock<std::mutex> lock(mutex_name);

cv.wait(lock, [&]() {

    return условие_продолжения;

});

  

// Уведомление из другого потока

cv.notify_one();    // пробудить один поток

cv.notify_all();    // пробудить все потоки

```

  

**Порядок действий:**

1. Объявить условную переменную

2. В ожидающем потоке:

   - Захватить мьютекс

   - Вызвать `wait` с предикатом

3. В уведомляющем потоке:

   - Захватить мьютекс

   - Изменить общие данные

   - Вызвать `notify_one` или `notify_all`

   - Освободить мьютекс

  

## 4. Очереди для межпоточного обмена

  

```cpp

// Объявление очереди

std::queue<T> queue_name;

  

// Добавление в очередь

{

    std::lock_guard<std::mutex> lock(mutex_name);

    queue_name.push(data);

}

  

// Извлечение из очереди

{

    std::lock_guard<std::mutex> lock(mutex_name);

    if (!queue_name.empty()) {

        auto data = queue_name.front();

        queue_name.pop();

    }

}

```

  

**Порядок действий:**

1. Объявить очередь

2. При добавлении:

   - Захватить мьютекс

   - Добавить данные

   - Освободить мьютекс

3. При извлечении:

   - Захватить мьютекс

   - Проверить непустоту

   - Извлечь данные

   - Освободить мьютекс

  

## 5. Типичный паттерн работы с потоками

  

```cpp

// 1. Объявление необходимых объектов

std::mutex mutex;

std::condition_variable cv;

std::queue<Data> queue;

bool running = true;

  

// 2. Функция потока-потребителя

void consumer_thread() {

    while (running) {

        std::unique_lock<std::mutex> lock(mutex);

        cv.wait(lock, [&]() {

            return !queue.empty() || !running;

        });

        if (!running) break;

        auto data = queue.front();

        queue.pop();

        lock.unlock();

        // обработка data

    }

}

  

// 3. Функция потока-производителя

void producer_thread() {

    while (running) {

        Data data = produce_data();

        {

            std::lock_guard<std::mutex> lock(mutex);

            queue.push(data);

        }

        cv.notify_one();

    }

}

  

// 4. Запуск и остановка

void run() {

    std::thread consumer(consumer_thread);

    std::thread producer(producer_thread);

    // ... работа ...

    // Остановка

    {

        std::lock_guard<std::mutex> lock(mutex);

        running = false;

    }

    cv.notify_all();

    consumer.join();

    producer.join();

}

```

  

## 6. Важные правила

  

1. **Всегда используйте RAII**:

   - `std::lock_guard` вместо ручного `lock`/`unlock`

   - Умные указатели вместо сырых

   - Контейнеры STL вместо ручного управления памятью

  

2. **Избегайте deadlock'ов**:

   - Захватывайте мьютексы в одинаковом порядке

   - Минимизируйте время удержания блокировок

   - Не вызывайте `wait` без предиката

  

3. **Обрабатывайте исключения**:

   - Используйте try-catch в потоках

   - Гарантируйте освобождение ресурсов при исключениях

  

4. **Следите за жизненным циклом**:

   - Не допускайте висячих потоков

   - Корректно завершайте все потоки

   - Проверяйте условия выхода из циклов

  

5. **Оптимизируйте производительность**:

   - Используйте `notify_one` вместо `notify_all` где возможно

   - Минимизируйте размер критических секций

   - Используйте атомарные операции для простых случаев

  

## 7. Типичные ошибки

  

❌ Неправильно:

```cpp

mutex.lock();

// код

mutex.unlock();  // может быть пропущено при исключении

```

  

✅ Правильно:

```cpp

{

    std::lock_guard<std::mutex> lock(mutex);

    // код

}  // автоматическое освобождение

```

  

❌ Неправильно:

```cpp

cv.wait(lock);  // может проснуться без причины

```

  

✅ Правильно:

```cpp

cv.wait(lock, [&]() { return !queue.empty(); });

```

  

❌ Неправильно:

```cpp

if (!queue.empty()) {  // гонка данных

    auto data = queue.front();

}

```

  

✅ Правильно:

```cpp

std::lock_guard<std::mutex> lock(mutex);

if (!queue.empty()) {

    auto data = queue.front();

}

```