Вот удобная "шпаргалка" по популярным паттернам проектирования в C++. Я постарался включить все часто используемые паттерны, описав их задачу, суть реализации и признаки распознавания в коде. Информация представлена кратко и структурировано.

---

### 1. Порождающие паттерны (Creational Patterns)

#### Singleton (Одиночка)
- **Задача**: Гарантировать, что у класса есть только один экземпляр, и предоставить глобальную точку доступа к нему.
- **Суть идеи**: Приватный конструктор, статический метод `getInstance()`, возвращающий единственный объект.
- **Как распознать**: Статический метод с именем вроде `getInstance()`, приватные конструкторы, статическая переменная для хранения объекта.

#### Factory Method (Фабричный метод)
- **Задача**: Делегировать создание объектов подклассам, позволяя гибко определять, какой класс создавать.
- **Суть идеи**: Абстрактный метод в базовом классе, который реализуется в подклассах для создания объектов.
- **Как распознать**: Абстрактный базовый класс с методом вроде `createProduct()`, переопределённым в наследниках.
  [Factory Method (Фабричный метод)](Factory%20Method%20(Фабричный%20метод).md)
  [Pattern. Factory Method (Фабричный метод)](шаблонная%20реализация/Pattern.%20Factory%20Method%20(Фабричный%20метод).md)
   
#### Abstract Factory (Абстрактная фабрика)
- **Задача**: Создавать семейства связанных объектов без указания их конкретных классов.
- **Суть идеи**: Интерфейс с методами для создания разных типов объектов, реализуемый конкретными фабриками.
- **Как распознать**: Интерфейс или абстрактный класс с несколькими методами `createX()`, возвращающими связанные объекты.
   [Разница между абстрактным методом и фабрикой.](Разница%20между%20абстрактным%20методом%20и%20фабрикой..md)
   

#### Builder (Строитель)
- **Задача**: Разделить процесс создания сложного объекта от его представления.
- **Суть идеи**: Отдельный класс `Builder` с методами для пошагового построения, возвращающий готовый объект через `build()`.
- **Как распознать**: Класс с цепочкой методов вроде `setX()`, финальный метод `build()`, возвращающий результат.

#### Prototype (Прототип)
- **Задача**: Создавать новые объекты путём копирования существующего экземпляра.
- **Суть идеи**: Метод `clone()` в классе, который возвращает копию объекта.
- **Как распознать**: Интерфейс или метод `clone()`, использующий копирование (например, через `new` или `memcpy`).

---

### 2. Структурные паттерны (Structural Patterns)

#### Adapter (Адаптер)
- **Задача**: Преобразовать интерфейс одного класса в интерфейс, ожидаемый клиентом.
- **Суть идеи**: Класс-обёртка, который вызывает методы адаптируемого объекта через свой интерфейс.
- **Как распознать**: Класс, реализующий один интерфейс, но содержащий указатель/объект другого класса.

#### Bridge (Мост)
- **Задача**: Отделить абстракцию от её реализации, чтобы они могли изменяться независимо.
- **Суть идеи**: Абстрактный класс с указателем на интерфейс реализации, который можно менять.
- **Как распознать**: Абстрактный класс с указателем на другой интерфейс, методы которого делегируют работу.

#### Composite (Компоновщик)
- **Задача**: Объединить объекты в древовидную структуру для работы с ними как с единым целым.
- **Суть идеи**: Общий интерфейс для листьев и контейнеров, рекурсивная обработка в контейнерах.
- **Как распознать**: Интерфейс с методом вроде `operation()`, реализация с контейнером (например, `std::vector`) дочерних объектов.

#### Decorator (Декоратор)
- **Задача**: Динамически добавлять обязанности объекту без изменения его кода.
- **Суть идеи**: Класс-обёртка, наследующий интерфейс и содержащий указатель на декорируемый объект.
- **Как распознать**: Наследование интерфейса, конструктор принимает указатель на объект того же типа.

#### Facade (Фасад)
- **Задача**: Предоставить простой интерфейс к сложной подсистеме.
- **Суть идеи**: Класс с методами, скрывающими взаимодействие с несколькими классами подсистемы.
- **Как распознать**: Класс с простыми методами, вызывающими цепочку операций в других классах.

#### Flyweight (Легковес)
- **Задача**: Уменьшить затраты памяти при работе с большим количеством схожих объектов.
- **Суть идеи**: Выделение неизменяемых данных в отдельный класс, который используется повторно.
- **Как распознать**: Класс с неизменяемыми полями, фабрика для управления общими экземплярами.

#### Proxy (Прокси)
- **Задача**: Контролировать доступ к объекту, добавляя дополнительную логику.
- **Суть идеи**: Класс, реализующий тот же интерфейс, что и целевой объект, с добавлением условий/логики.
- **Как распознать**: Класс с указателем на реальный объект, методы которого вызываются через проверки.

---

### 3. Поведенческие паттерны (Behavioral Patterns)

#### Chain of Responsibility (Цепочка ответственности)
- **Задача**: Передать запрос по цепочке обработчиков, пока один из них его не обработает.
- **Суть идеи**: Интерфейс с указателем на следующий обработчик, рекурсивная передача запроса.
- **Как распознать**: Классы с методом `handle()` и указателем на следующий объект в цепочке.

#### Command (Команда)
- **Задача**: Инкапсулировать запрос как объект, позволяя параметризовать действия.
- **Суть идеи**: Класс команды с методом `execute()`, содержащий логику действия.
- **Как распознать**: Интерфейс с `execute()`, объекты передаются в качестве аргументов.

#### Interpreter (Интерпретатор)
- **Задача**: Определить грамматику языка и интерпретировать выражения.
- **Суть идеи**: Классы для каждого правила грамматики с методом `interpret()`.
- **Как распознать**: Иерархия классов с рекурсивным вызовом `interpret()`.

#### Iterator (Итератор)
- **Задача**: Предоставить последовательный доступ к элементам коллекции без раскрытия её структуры.
- **Суть идеи**: Отдельный класс с методами `next()` и `hasNext()`.
- **Как распознать**: Класс с указателем на коллекцию, методы для обхода (например, `begin()`, `end()`).

#### Mediator (Посредник)
- **Задача**: Упростить взаимодействие между объектами, централизуя управление.
- **Суть идеи**: Класс-посредник, через который объекты обмениваются сообщениями.
- **Как распознать**: Класс с методами вроде `notify()`, объекты ссылаются на посредника.

#### Memento (Хранитель)
- **Задача**: Сохранить и восстановить состояние объекта без нарушения инкапсуляции.
- **Суть идеи**: Класс `Memento` для хранения состояния, методы `save()` и `restore()`.
- **Как распознать**: Внутренний класс для состояния, методы для его сохранения/восстановления.

#### Observer (Наблюдатель)
- **Задача**: Уведомлять зависимые объекты об изменениях состояния.
- **Суть идеи**: Интерфейс наблюдателя с методом `update()`, список подписчиков в субъекте.
- **Как распознать**: Метод `notify()`, контейнер указателей на наблюдателей.

#### State (Состояние)
- **Задача**: Изменять поведение объекта при изменении его состояния.
- **Суть идеи**: Интерфейс состояния, классы для каждого состояния, переключение через указатель.
- **Как распознать**: Класс с указателем на состояние, методы делегируют работу состоянию.

#### Strategy (Стратегия)
- **Задача**: Определить семейство алгоритмов и сделать их взаимозаменяемыми.
- **Суть идеи**: Интерфейс стратегии, конкретные классы реализуют алгоритмы.
- **Как распознать**: Указатель на интерфейс стратегии, методы вызывают её поведение.

#### Template Method (Шаблонный метод)
- **Задача**: Определить скелет алгоритма, позволяя подклассам переопределять шаги.
- **Суть идеи**: Абстрактный класс с финальным методом, вызывающим виртуальные шаги.
- **Как распознать**: Финальный метод в базовом классе, виртуальные методы переопределяются.

#### Visitor (Посетитель)
- **Задача**: Добавить новые операции к объектам без изменения их классов.
- **Суть идеи**: Интерфейс посетителя с методами `visit()` для каждого типа объекта.
- **Как распознать**: Метод `accept()` в классе, принимающий посетителя.

---

Эта шпаргалка охватывает 23 классических паттерна из книги "Банды четырёх" (GoF), которые наиболее часто используются в C++. Надеюсь, она будет удобной для быстрого参考! Если нужно что-то дополнить или уточнить, дай знать!